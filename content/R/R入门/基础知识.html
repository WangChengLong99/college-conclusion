---
title: R基础知识
date: 2022-8-10
lastmod: '2022-08-09T16:44:38+08:00'
type: book
summary: 包，帮助，运算，文件，函数，可视化
weight: 1
toc: true
---


<div id="TOC">

</div>

<div id="包的安装载入查找更新卸除加载的包删除包" class="section level1">
<h1>包的安装，载入，查找，更新，卸除加载的包，删除包</h1>
<table>
<thead>
<tr class="header">
<th>功能</th>
<th align="left">函数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>安装</td>
<td align="left">install.packages(“包名”)</td>
</tr>
<tr class="even">
<td>查找</td>
<td align="left">library() 可以查找所有已经安装的包</td>
</tr>
<tr class="odd">
<td>载入</td>
<td align="left">library(“包名”)</td>
</tr>
<tr class="even">
<td>卸除加载的包（并未删除）</td>
<td align="left">detach(“包名”)</td>
</tr>
<tr class="odd">
<td>更新</td>
<td align="left">updata.packages(“包名”)</td>
</tr>
<tr class="even">
<td>删除</td>
<td align="left">remove.packages(“包名”)</td>
</tr>
</tbody>
</table>
</div>
<div id="查看帮助信息" class="section level1">
<h1>查看帮助信息</h1>
<table>
<colgroup>
<col width="50%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">函数</th>
<th>用途</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">help.start()</td>
<td>直接进入一个帮助文档的总页面</td>
<td>help.start()<br/>{{%figure src="./data/help_start.png"%}}</td>
</tr>
<tr class="even">
<td align="left">help(函数名)/?函数名</td>
<td>显示该函数的帮助页面,但是有时候寻找的只是已经载入的包中，可以加上 <code>try.all.packages=TRUE</code> 来让它搜索所有的包。同时对于某些特殊的函数必须使用双引号，比如if等。</td>
<td>help(mean)<br/>{{%figure src="./data/help.png"%}}<br/>help(“bs”)<br/>No documentation for ‘bs’ in specified packages and libraries:you could try ‘??br’<br/>help(“bs”,try.all.packages=TRUE)<br/>Help for topic ‘bs’ is not in any loaded package but can be found in the following packages:<br/>Package Library<br/>splines D:/R/R-3.6.3/library</td>
</tr>
<tr class="odd">
<td align="left">apropos(“字符串”)</td>
<td>搜索含有该字符串的函数的帮助文档，但是只是在已经安装的包中寻找</td>
<td>apropos(“means”)<br/>{{%figure src="./data/apropos.png"%}}</td>
</tr>
<tr class="even">
<td align="left">help.search(“字符串”)</td>
<td>列出所有在<strong>帮助页面</strong>中含有该字符串的函数，不仅仅是名字</td>
<td>help.search(“mean”)<br/>{{%figure src="./data/help_search.png"%}}</td>
</tr>
<tr class="odd">
<td align="left">find(“函数名”)</td>
<td>找出含有该函数的程序包</td>
<td>find(“mean”)<br/>r$&gt; find(“mean”)<br/>[1] “package:Matrix” “package:base”</td>
</tr>
</tbody>
</table>
</div>
<div id="变量常量和赋值" class="section level1">
<h1>变量，常量和赋值</h1>
<p>r是基于对象的语言，变量名实际就是对象名。</p>
<p>变量名由点号，下划线，字母，数字组成，以字母或下划线开头，或者在这两个前面加个点号也行。</p>
<p>有了变量就可以赋值，可以用 =，-&gt; ,&lt;- 来赋值。</p>
<p>常量就是不变的值。</p>
</div>
<div id="运算符与运算函数" class="section level1">
<h1>运算符与运算函数</h1>
<p>运算符是特殊的函数，分为算数运算符，比较运算符，逻辑运算符，赋值符，和其他运算符。</p>
<p>算数运算符&gt;比较运算符&gt;逻辑运算符&gt;赋值符</p>
<p>算数运算符中：指数&gt;乘除&gt;加减</p>
<p>比较运算符：无大小</p>
<p>逻辑运算符：!&gt;&amp;&gt;| 非大于并大于或</p>
<p>常见运算符：</p>
<table>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th>符号</th>
<th>含义</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>算数运算符</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>+,-</td>
<td>加，减</td>
<td></td>
</tr>
<tr class="odd">
<td>*,/</td>
<td>乘，除</td>
<td>5/3 为浮点数</td>
</tr>
<tr class="even">
<td>%%</td>
<td>求余</td>
<td></td>
</tr>
<tr class="odd">
<td>%/%</td>
<td>求整</td>
<td>5%/%3 为 1</td>
</tr>
<tr class="even">
<td>^</td>
<td>幂</td>
<td></td>
</tr>
<tr class="odd">
<td>比较运算符</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>&gt;,&lt;,&gt;=,&lt;=,==,!=</td>
<td>大于，小于，大于等于，小于等于，等于，不等于</td>
<td></td>
</tr>
<tr class="odd">
<td>逻辑运算符</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>！</td>
<td>非，取逻辑值的反运算</td>
<td>!TRUE</td>
</tr>
<tr class="odd">
<td>&amp;</td>
<td>并，比较的对象全为真才是真</td>
<td>TRUE&amp;FALSE<br/>[1] FALSE<br/>c(TRUE,TRUE)&amp;c(TRUE,FALSE)<br/>[1] TRUE FALSE</td>
</tr>
<tr class="even">
<td>&amp;&amp;</td>
<td>如果比较的是向量只比较第一组值。</td>
<td>c(TRUE,TRUE)&amp;&amp;c(TRUE,FALSE)<br/>[1] TRUE<br/>c(FALSE,TRUE)&amp;&amp;c(TRUE,FALSE)<br/>[1] FALSE</td>
</tr>
<tr class="odd">
<td>|</td>
<td>或</td>
<td></td>
</tr>
<tr class="even">
<td>||</td>
<td>如果比较的是向量只比较第一组值。</td>
<td></td>
</tr>
<tr class="odd">
<td>xor</td>
<td>异或，两个逻辑值不一致时为真</td>
<td>xor(TRUE,FALSE)<br/>[1] TRUE</td>
</tr>
<tr class="even">
<td>赋值符</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>=，&lt;-</td>
<td>赋值</td>
<td></td>
</tr>
<tr class="even">
<td>其他运算符</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>$</td>
<td>提取符</td>
<td></td>
</tr>
<tr class="even">
<td>%*%</td>
<td>矩阵相乘</td>
<td></td>
</tr>
<tr class="odd">
<td>all()</td>
<td>一个向量中所有值全为真则为真</td>
<td></td>
</tr>
<tr class="even">
<td>any()</td>
<td>一个向量中有值为真则为真</td>
<td></td>
</tr>
</tbody>
</table>
<p>常用运算函数：</p>
<pre><code>x=c(1,2,3,4)
x2=c(5,6,7,8)
y=matrix(c(1,2,3,4,5,6,7,8),2,4)
y2=matrix(c(3,8,5,7,3,6,7,4,2),3,3)
z=c(&#39;a&#39;,&#39;c&#39;,&#39;b&#39;)</code></pre>
<table>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th>功能</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>sum(x)</td>
<td>求和</td>
<td>sum(x) 10<br/>sum(y) 36</td>
</tr>
<tr class="even">
<td>range(x)</td>
<td>查看数值的范围</td>
<td>range(z)<br/>[1] “a” “c”<br/>range(x)<br/>[1] 1 4<br/> range(y)<br/>[1] 1 8</td>
</tr>
<tr class="odd">
<td>length(x)</td>
<td>返回数据长度</td>
<td>r$&gt; length(x)<br/>[1] 4<br/> length(y)<br/>[1] 8</td>
</tr>
<tr class="even">
<td>prod(x)</td>
<td>序列中所有值相乘</td>
<td>prod(x)<br/>[1] 24<br/> prod(x,x2)<br/>[1] 40320<br/>prod(y)<br/>[1] 40320</td>
</tr>
<tr class="odd">
<td>mean(x)</td>
<td>求所有值的平均值</td>
<td>mean(x)<br/>[1] 2.5<br/>mean(y)<br/>[1] 4.5</td>
</tr>
<tr class="even">
<td>max(x)</td>
<td>求最大值</td>
<td>max(z)<br/>[1] “c”</td>
</tr>
<tr class="odd">
<td>median(x)</td>
<td>中位数</td>
<td>median(z)<br/>[1] “b”</td>
</tr>
<tr class="even">
<td>min(x)</td>
<td>求最小值</td>
<td></td>
</tr>
<tr class="odd">
<td>cov(x,y)</td>
<td>求协方差</td>
<td>矩阵每一列是一个变量<br/>cov(y2)<br/> [,1] [,2] [,3]<br/>[1,] 6.333333 -5.166667 -3.166667<br/>[2,] -5.166667 4.333333 1.833333<br/>[3,] -3.166667 1.833333 6.333333</td>
</tr>
<tr class="even">
<td>cor(x,y)</td>
<td>求两个变量之间相关系数</td>
<td></td>
</tr>
<tr class="odd">
<td>var(x)</td>
<td>对矩阵求协方差，对向量求方差</td>
<td>var(y2)<br/> [,1] [,2] [,3]<br/>[1,] 6.333333 -5.166667 -3.166667<br/>[2,] -5.166667 4.333333 1.833333<br/>[3,] -3.166667 1.833333 6.333333<br/>var(y2[,1])<br/>[1] 6.333333</td>
</tr>
<tr class="even">
<td>cor(x)</td>
<td>求矩阵的相关系数</td>
<td>cor(y2)<br/> [,1] [,2] [,3]<br/>[1,] 1.0000000 -0.9862414 -0.5000000<br/>[2,] -0.9862414 1.0000000 0.3499566<br/>[3,] -0.5000000 0.3499566 1.0000000</td>
</tr>
<tr class="odd">
<td>which.max(x)</td>
<td>返回第一个最大值的位置</td>
<td>which.max(y2)<br/>[1] 2<br/>which.max(c(1,2,2,1))<br/>[1] 2</td>
</tr>
<tr class="even">
<td>which.min(x)</td>
<td>返回第一个最小值的位置</td>
<td></td>
</tr>
<tr class="odd">
<td>round(x, n)</td>
<td>转置</td>
<td></td>
</tr>
<tr class="even">
<td>pmin(x,y,…)</td>
<td>对所有向量或矩阵的值进行比较，长度不等可以循环，取较小的值组成一个与最长长度相同的向量</td>
<td>pmin(x,x2)<br/>[1] 1 2 3 4<br/> pmin(y,y2)<br/>[1] 1 2 3 4 3 6 7 4 1</td>
</tr>
<tr class="odd">
<td>pmax(x,y,…)</td>
<td>返回所有最大值</td>
<td></td>
</tr>
<tr class="even">
<td>rev(x)</td>
<td>倒序</td>
<td>rev(x)<br/>[1] 4 3 2 1<br/>rev(y2)[1] 2 4 7 6 3 7 5 8 3</td>
</tr>
<tr class="odd">
<td>sort(x)</td>
<td>排序</td>
<td>sort(y2)<br/>[1] 2 3 3 4 5 6 7 7 8</td>
</tr>
<tr class="even">
<td>cumsum(x)</td>
<td>累加</td>
<td>cumsum(x)<br/>[1] 1 3 6 10</td>
</tr>
<tr class="odd">
<td>rank(x,ties.method=?)</td>
<td>对一维数组或向量进行排序，给每个值赋予一个排名，对相同值排名有五种规则（first：从小到大，相同值先出现的小，max：取最好水平，min：取最差水平，average：取平均水平，random：随机排名）</td>
<td>rank(c(6,9,10,3,9,5),ties.method=?)<br/>“first”:3 4 6 1 5 2<br/>“max”:3 5 6 1 5 2<br/>“min”:3 4 6 1 4 2<br/>“average”:3.0 4.5 6.0 1.0 4.5 2.0<br/>“random”:3 5 6 1 4 2</td>
</tr>
<tr class="even">
<td>cumprod(x)</td>
<td>累乘</td>
<td>cumprod(x)<br/>[1] 1 2 6 24</td>
</tr>
<tr class="odd">
<td>log(x,base)</td>
<td>求对数</td>
<td>log(5,80)<br/>[1] 0.3672816<br/>log(80,5)[1] 2.722706</td>
</tr>
<tr class="even">
<td>cummin(x)</td>
<td>输出目前为止碰到的最小值，如果后面碰到了更小的，就变成更小的值，依次往下推</td>
<td>cummin(y2)<br/>[1] 3 3 3 3 3 3 3 3 2<br/>cummin(c(3,5,2,4,1,0))<br/>[1] 3 3 2 2 1 0</td>
</tr>
<tr class="odd">
<td>cummax(x)</td>
<td>输出目前为止碰到的最大值，如果后面碰到了更大的，就变成更大的值，依次往下推</td>
<td></td>
</tr>
<tr class="even">
<td>scale(x，center，scale)</td>
<td>规范化处理，归1化。center为true时，减去均值，false不减；scale为true时除标准差，false不除。两个值默认都为true，所以x_i=(x_i-mean(x))/sd(x)</td>
<td>{{%figure src="./data/scale.png"%}})</td>
</tr>
<tr class="odd">
<td>unique(x)</td>
<td>去除掉重复元素的向量数据框或数组</td>
<td>unique(c(1,3,3,7,5,4))<br/>[1] 1 3 7 5 4<br/>unique(matrix(c(1,2,1,3,5,3),3,2))<br/> [,1] [,2]<br/>[1,] 1 3<br/>[2,] 2 5<br/>矩阵去掉的是重复行</td>
</tr>
<tr class="even">
<td>match(x,y)</td>
<td>返回x中元素在y中的位置，有的返回位置，没有的返回na</td>
<td>match(c(3,1),c(1,3))<br/>[1] 2 1<br/>match(c(4,3),c(4,1))<br/>[1] 1 NA</td>
</tr>
<tr class="odd">
<td>sample(x,size)</td>
<td>从向量或数据框等中随机抽取n个数</td>
<td>sample(x,2)<br/>[1] 3 1<br/>sample(y,2)<br/>[1] 4 3<br/>sample(y,2)<br/>[1] 6 4</td>
</tr>
<tr class="even">
<td>which(x == a)</td>
<td>返回所有等于a的值的位置</td>
<td>which(y2==3)<br/>[1] 1 5<br/>which(x==2)<br/>[1] 2</td>
</tr>
</tbody>
</table>
</div>
<div id="文件读写" class="section level1">
<h1>文件读写</h1>
<div id="设定路径" class="section level2">
<h2>设定路径</h2>
<p>利用getwd函数获取当前路径
利用setwd函数，设定路径，之后的路径如果不设置就是默认在这个路径下，如果设置了其他的，可以是跟在这个路径之后。也可以是一个跟这个路径无关的新路径。</p>
<pre class="r"><code>getwd()#&quot;C:/Users/WangChengLong/Desktop/R/R总结&quot;</code></pre>
<pre><code>## [1] &quot;D:/Rblog/rblog/content/R/R入门&quot;</code></pre>
<pre class="r"><code># setwd(&quot;D:/code&quot;)#setwd(&quot;D:\\code&quot;)正斜杠或双反斜杠
# read.csv(file=&quot;data/GDP.csv&quot;)#D:/code/data/gdp.csv
# read.table(&quot;Rtest.txt&quot;)#D:/code/Rtest.txt
# read.csv(file=&quot;D:/R/data/shop.csv&quot;)</code></pre>
</div>
<div id="读取纯文本文件" class="section level2">
<h2>读取纯文本文件</h2>
<p>并不是单纯的纯文本，而是有一定格式的纯文本。并不是文章之类的文本。</p>
<table>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th>使用</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>read.table()</td>
<td>以数据框的形式读取具有多列表格形式的文件数据<br/>file∶文件路径<br/>header∶逻辑值，用于指出文件的第一行是否为数据变量的名字。一般默认为header=F。如果第一行比其他行少一列，则默认第一列为行名，第一行为列名。<br/>sep∶字符型，数据的分隔符。默认情况下，sep=““，此参数用于指定<strong>数据文件中</strong>每行中数据之间使用的分隔符。<br/>quote∶指定包围字符型数据的字符。默认情况下，字符串可以被”或’括起，并且两种情况下，引号内部的字符都作为字符串的一部分。<br/> dec∶字符型，制定小数点字符，默认为”.”一般不用修改.<br/> row.names∶保存行名的向量。未定义时以1、2、3、4.…代替. <br/>col.names∶指定列名的向量。缺省情况下是用”V”加上列序构成，即V1，V2，V3.<br/>nroWS∶整型数，用于指定从文件中读取的最大行数。<br/>skip∶整型数，读取数据时从前面开始忽略的行数。</td>
<td>read.table(file=“D:/R/data/house.data.txt”,sep=““,nrows=5)<br/>read.table(file=”D:/R/data/house.data.txt”,sep=““,header=T,nrows=2)<br/>read.table(file=”D:/R/data/house.data.txt”,header=T,nrows=5,quote=“"’”)</td>
</tr>
<tr class="even">
<td>read.csv()</td>
<td>以数据框的格式读取逗号分隔的数据文件，默认header</td>
<td></td>
</tr>
<tr class="odd">
<td>=TRUE。是read.table的变形</td>
<td>read.csv(file, header = TRUE, sep =“,”,quote=“"”,dec =“.”,…)</td>
<td></td>
</tr>
<tr class="even">
<td>read.csv2()</td>
<td>以数据框的格式读取分号分隔的数据文件，默认header</td>
<td></td>
</tr>
<tr class="odd">
<td>=TRUE。是read.table的变形</td>
<td>read.csv2(file, header = TRUE, sep =“,”,quote=“"”,dec =“.”,…)</td>
<td></td>
</tr>
<tr class="even">
<td>scan()</td>
<td>在R语言中可以使用scan（）函数从文本文件中读取数据或从键盘直接获取用户输入的数据。<br/>scan(file =“, what = double(), sep =”“, quote,</td>
<td></td>
</tr>
</tbody>
</table>
<p>deC =“.”,skip= 0,nlines=0,…)
<br/>file∶用于指定要读取文件的路径和名字，如果为空或”“，则是要从键
盘中获取数据。
<br/>what∶用于给出要读取的数据的类型，支持的数据类型包括∶logical，，
integer， numeric， complex， character以及list。<br/>sep∶用于指出文件中数据的分隔符，Scan默认数据是以空白进行分
隔。<br/>quote∶制定包围字符型数据的字符。<br/>dec∶字符型，制定小数点字符，默认为”“。<br/>skip∶用于指定读取数据时，忽略文件前面的行数.<br/>nlines∶指定要读取文件中数据的最大行数。
|<br/>{{%figure src="./data/scan.png"%}}<br/>回车之后再回车代表输入的结束
read.fwf()|可以用来读取每一列数据宽度固定的数据<br/>read. fwf(file, widths, header =FALSE, sep =”
skip=0, row.names, col.names,…)
|{{%figure src="data/read.fwf.png"%}}</p>
</div>
<div id="读取excel数据" class="section level2">
<h2>读取excel数据</h2>
<p>{{%figure src="data/excel.png"%}}</p>
</div>
<div id="读取r中数据集" class="section level2">
<h2>读取R中数据集</h2>
<ul>
<li>使用<code>data()</code>可列出R中自带的全部的数据集</li>
<li>某些数据集存在某些包中，导入包后，还需要使用data(数据集名)来加载数据集,如<code>data(package="survival")</code></li>
<li>{{%figure src="data/attach.png"%}}</li>
</ul>
</div>
<div id="其他格式数据的读取" class="section level2">
<h2>其他格式数据的读取</h2>
<p>{{%figure src="data/duqu.png"%}}</p>
</div>
<div id="写数据" class="section level2">
<h2>写数据</h2>
<p>写数据分为两种，一种是存入已有的文件中，一种是创建新的文件</p>
<table>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th>参数</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>write.table</td>
<td>写纯文本数据,新文件<br/>write.table(gnp,file=“…\lecture 2\GNP.txt”)</td>
<td></td>
</tr>
<tr class="even">
<td>write.csv</td>
<td>写excel数据，新文件<br/>write.csv(gnp,file=“…\lecture 2\GNP.csv”)</td>
<td></td>
</tr>
<tr class="odd">
<td>write()</td>
<td>既可以新文件，也可以写入，取决于append参数<br/>X∶数据，通常是矩阵、向量等。<br/>file∶是文件名<br/> append∶默认为FALSE，append=TRUE指在原文件上填加数据</td>
<td></td>
</tr>
<tr class="even">
<td>sink</td>
<td>之后输出的数据会被输出到该文件中。如果是一个新文件那么之后的输出都会显示在里面。不管append的T或F；但是如果是一个已有文件，那么如果不设置append=T，那么源文件中原本存在的都会被删除或者说替代。之后的所有输出还是出现在文件中<br/>sink(file=““,append=FALSE,…)</td>
<td>sink(file=“data/sink1.txt”,append=F)<br/>print(x)<br/>print(x)<br/>print(x)<br/>第一次运行改程序，会创建一个新的sink1.txt文件，在里面输入三个x数据。但是在第二次运行时，里面不是6个，依然是三个，因为append是false，原来的被清除了。</td>
</tr>
<tr class="odd">
<td>cat()</td>
<td>既能输入到屏幕也能输入到文件中，取决于有无设置file属性<br/>cat(…,file =““, sep =”“,append=F)</td>
<td></td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="数据类型和类型转换" class="section level1">
<h1>数据类型和类型转换</h1>
<div id="数据类型" class="section level2">
<h2>数据类型</h2>
<ul>
<li>数值型（numeric） 1e23,inf,-inf,NaN表示不是数字的<br/>5/0，inf+inf为inf；inf-inf,0/0的结果为NaN。</li>
<li>逻辑型（complex） 包括FALSE，TRUE，和NA（缺失值）</li>
<li>复数型（logical）</li>
<li>字符型 （character）单或双引号包括</li>
</ul>
</div>
<div id="数据对象" class="section level2">
<h2>数据对象</h2>
<p>{{%figure src="data/数据对象类型.png"%}}</p>
<p>{{%figure src="data/数据类型.png"%}}</p>
<p>列表可以看成数据框的一列，向量，矩阵，数组可以是一维二维和多维的关系。</p>
</div>
<div id="对象的属性" class="section level2">
<h2>对象的属性</h2>
<p>对象有内在属性（类型（mode）和长度）和其他属性（维度（dim）和类（class）等），可以用一些函数查看对象的属性。</p>
<ul>
<li><p>mode(x) 查看数据对象类型</p></li>
<li><p>length(x) 查看数据对象长度</p></li>
<li><p>attributes(x) 查看数据对象其他属性，不包括mode和length</p></li>
<li><p>attr(x,属性名称) 可以查看对象某一属性</p></li>
<li><p>attr(x,“names”)=?? 为对象的names属性更改值或者为对象x添加names属性。</p>
<p>x=c(NA)
attr(x,“mode”) #NULL</p></li>
</ul>
</div>
<div id="数据类型判断和转化" class="section level2">
<h2>数据类型判断和转化</h2>
<pre><code>x=c(NA)
#判断：
is.numeric(x)#F
is.character(x)#F
is.logical(x)#T
is.complex(x)#F

# 转化

y=as.numeric(x)
mode(x)#x类型并没有变
mode(y)#y类型变化，为数值型的NA
y#NA</code></pre>
<ul>
<li>is.nan 检测数据是否不确定，true为不确定</li>
<li>is.infinite 监测数据是否为无限值。true为无限</li>
<li>is.finite 检测数据是否为有限值，true为有限</li>
<li><code>is.na</code> 判断数据是否存在缺失值</li>
</ul>
</div>
</div>
<div id="控制符和循环" class="section level1">
<h1>控制符和循环</h1>
<div id="分支语句" class="section level2">
<h2>分支语句</h2>
<p>分支语句是用来判断的，条件满足则执行，条件不满足则不执行。</p>
<p>主要有下面五种</p>
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th>语句</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>if语句</td>
<td>if()每个if语句只要条件满足就会执行</td>
</tr>
<tr class="even">
<td>if <br/>……else……</td>
<td>if条件满足执行if下的语句，否则执行else下的语句</td>
</tr>
<tr class="odd">
<td>ifelse</td>
<td>ifelse（？，x，y）满足条件为x，不满足为y，返回结果的长度和判断生成的逻辑值数目一致。有多少个逻辑值。就会返回多少个结果。<br/>ifelse(?,c()，c()),满足时，取第一个向量的第i个，否则取第二个向量的第i个,向量中的元素可以循环取。</td>
</tr>
<tr class="even">
<td>if<br/>…… else if<br/>……else if<br/>……else</td>
<td>只要有一个条件满足，其他条件就不会再执行。</td>
</tr>
<tr class="odd">
<td>switch</td>
<td>switch(con,list)或<br/>switch(con,case1,case2,case3,…)<br/>switch是多分支语句，一次<strong>只能比较一个变量</strong>，比较的可以是下标，如，1，2.如果下标范围在列表长度内，返回对应位置元素，否则什么都不返回。如果列表元素是有names的，则还可以通过names比较。</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：</p>
<p><span style="color:red">else或else if不可前面无其他内容，也就是不可以另起一行或者放在开头，一般是放在上一个if的内容后面</span></p>
<ul>
<li><p>ifelse 与 if else的区别：</p>
<p>ifelse（con，expr1，expr2）中的条件判断中可以得到多个逻辑结果，有多少个逻辑结果，ifelse（）的返回值就有多少个元素，且不同的逻辑结果取不同的值。</p>
<p>if（con) expr1 else expr2中的条件判断中只得到一个逻辑结果（如果
有多个逻辑结果，会自动取第一个，并抛出警告）。然后根据这个逻辑结果，取后面表达式的值。</p></li>
<li><p>if语句各判断条件的位置关系：</p>
<p>if语句可以有零个或一个else，但如果有else if语句，那么else语句必须在else if语句之后。</p>
<p>if语句可以有零或多个else if语句，else if语句必须放在else语句之前。</p>
<p>当有一个else if条件测试成功，其余的else.….if或else将不会被测试。</p></li>
</ul>
</div>
<div id="循环语句" class="section level2">
<h2>循环语句</h2>
<p>循环语句主要有for，while和repeat循环</p>
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th>语句</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>for</td>
<td>for（name in expr1）expr2 <br/>name 是一个循环变量，expr1是他的取值范围，直到循环结束前，每一次都执行下面的expr2</td>
</tr>
<tr class="even">
<td>while</td>
<td>while（con）expr <br/>con一般是循环终止条件，在expr中一般有变量的循环。运行直到终止条件满足。</td>
</tr>
<tr class="odd">
<td>repeat</td>
<td>repeat expr<br/>repeat 是无条件运行expr，而在expr中需要设置满足条件后的break语句，来将整个循环终止。</td>
</tr>
</tbody>
</table>
</div>
<div id="break和next" class="section level2">
<h2>break和next</h2>
<p>break将整个循环终止，而next是跳过循环的某一步，执行下一步。</p>
</div>
</div>
<div id="函数" class="section level1">
<h1>函数</h1>
</div>
<div id="可视化" class="section level1">
<h1>可视化</h1>
<p>可视化分为高级作图函数，低级作图函数，图形参数，网格作图，多图。当然还有一些包中的绘图函数是为了特定的需求。</p>
<p>低级作图函数必须建立在已有高级图形的基础上，低级作图函数一般是在高级图形上添加点，线等。</p>
<p>图形参数是用来调整一个图形，比如坐标轴，图例等。</p>
<p>网格作图是为了在一张画布上显示多个图形，有时候会有对比图形的需求。我们需要一些灵活的方式来实现多图。</p>
<div id="高级绘图函数" class="section level2">
<h2>高级绘图函数</h2>
</div>
</div>
