---
title: 正则表达式
date: 2022-12-6
lastmod: '2022-12-064T16:44:38+08:00'
summary: 正则表达式总结
weight: 50
toc: true
type: book
---

## 常用总结

{{%spoiler text=\"常用\"%}}
### 怎样替换多余的空行

`^ *\n\n`替换为`\n`多次使用

### 怎样让所有标题层级下降一级

`^#`替换为`##`
{{%/spoiler%}}

## 正则化表达式

在介绍python的正则化表达式之前，我们先介绍正则表达式的字符串写法，这样我们才能在python中生成正则化对象。正则表达式可以看成一种匹配的模式，他会寻找那些字符串中的匹配部分或者是寻找匹配的字符串。

正则表达式由普通字符和元字符组成。普通字符就是正常的字母加上数字。元字符是一些特殊符号和一些反斜杠加字母或数字的组合。在python中如果元字符与转义字符重复，需要在元字符前再加一条斜杠或者把正则表达式写成原生字符串的形式，即r“字符串”，在字符串前加个r，代表原生字符串，反斜杠不再转义。要想在字符串中检索一些是正则表达式中的元字符的字符必须在该字符前加上\\,一般匹配所有的标点符号和括号都需要加上\\。

元字符|描述
:-:|:-
\\	|将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。
^	|匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。
\$|匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，\$ 也匹配 '\n' 或 '\r' 之前的位置。
\*	|匹配前面的子表达式零次或多次。例如，zo\* 能匹配 "z" 以及 "zoo"。\* 等价于{0,}。
\+	|匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
\?	|匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 。\? 等价于 {0,1}。
{n}	|n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
{n,}	|n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
{n,m}	|m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。
\?	|当该字符紧跟在任何一个其他限制符 (\*, \+, \?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。
.	|匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用像"(.\|\\n)"的模式。
(pattern)	|匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 \$0…\$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。
(\?:pattern)	|匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (\|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y\|ies) 就是一个比 'industry\|industries' 更简略的表达式。
(\?=pattern)	|正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95\|98\|NT\|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(\?!pattern)	|正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如"Windows(?!95\|98\|NT\|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(\?\<=pattern)|	反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，"(?<=95\|98\|NT\|2000)Windows"能匹配"2000Windows"中的"Windows"，但不能匹配"3.1Windows"中的"Windows"。
(\?\<!pattern)|	反向否定预查，与正向否定预查类似，只是方向相反。例如"(?<!95\|98\|NT\|2000)Windows"能匹配"3.1Windows"中的"Windows"，但不能匹配"2000Windows"中的"Windows"。
(\?P\<groupname\>)|为子模式命名
(\?iLmsux)	|设置匹配标志，可以是几个字母的组合，每个字母含义与编译标志相同
(\?P=groupname)	|表示在此之前的命名为groupname的子模式
(\?#...)	|表示注释                                                    
x\|y	|匹配 x 或 y。例如，'z\|food' 能匹配 "z" 或 "food"。'(z\|f)ood' 则匹配 "zood" 或 "food"。
[xyz]	|字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。
[^xyz]	|负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。
[a-z]	|字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。
[^a-z]	|负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。
\b	|匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
\B	|匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
\cx	|匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
\d	|匹配一个数字字符。等价于 [0-9]。
\D	|匹配一个非数字字符。等价于 [^0-9]。
\f	|匹配一个换页符。等价于 \x0c 和 \cL。
\n	|匹配一个换行符。等价于 \x0a 和 \cJ。
\r	|匹配一个回车符。等价于 \x0d 和 \cM。
\s	|匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S	|匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\t	|匹配一个制表符。等价于 \x09 和 \cI。
\v	|匹配一个垂直制表符。等价于 \x0b 和 \cK。
\w	|匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。
\W	|匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。
\xn	|匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。
\num|匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。
\n	|标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。
\nm	|标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。
\nml	|如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。
\un	|匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。

### 普通字符

普通字符只需自己直接输入，然后匹配相应数量的连续字符即可。

### 元字符

元字符除了用来分组的（），选择字符，限定字符以及定位元素外，一个元字符匹配一个长度的字符。限定字符可以规定正则表达式中的字符的重复次数，从而匹配多个长度的字符。定位元素可以对某些位置的元素做出匹配的规定，分组（）可以将一些部分放在一起作为一个整体看待。分组也被称为子模式或子表达式。python中可以获取每个分组的结果。

### 限定字符

限定字符的默认匹配模式是贪心模式，即会找到该字符串中和模式匹配的最大子字符串。而通过在限定符后再加上个?号限定符，那么就会变成非贪心模式，会变成找最短的匹配字符串。**注意s限定符，他代表了一种可选的含义，在很多时候很有用**

### 定位元素

定位元素主要由\^,\\b,\\B,\$组成。他们确定了一些特殊位置。通过在正则表达式两侧加上\^和\$，这个正则表达式就是对一整个字符串的匹配。而不是只需有元素匹配。\\b主要用来确定单词。\\B主要用来匹配非单词。

### 组合和选择

组合就是用方括号把一些字符给组合起来，看成一个子模式或者说一个整体，对这个整体进行匹配。而选择就是在括号中设置一些匹配的条件。这些条件可以是对某个字符的前后要求，也可以是对整个字符串的要求。注意正向和反向，先行和后行。

### 反向引用

反向引用是在一个正则表达式中对之前的子模式的引用，比如我们现在查找一个字符串中重复的单词，我们把单词设置为一个子模式，这样匹配的模式应该是下一个单词等于上一个单词，即上一个子模式的值。所以在构造正则表达式时，就会涉及到反向引用。

### 修饰符

修饰符|	含义|	描述
-|-|-
i|	ignore - 不区分大小写	|将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。
g|	global - 全局匹配|	查找所有的匹配项。
m|	multi line - 多行匹配|	使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。
s|	特殊字符圆点 . 中包含换行符 \\n|	默认情况下的圆点 . 是 匹配除换行符 \n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \n。

在python中一般是t通过flags参数设置，但是字符的设置就不一样了，python有它自己的设置方式。

### 运算优先级

运算符|描述
:-|:-
\	|转义符
(), (?:), (?=), []	|圆括号和方括号
*, +, ?, {n}, {n,}, {n,m}|限定符
^, $, \任何元字符、任何字符|	定位点和序列（即：位置和顺序）
\||替换，"或"操作.字符具有高于替换运算符的优先级，使得"m\|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m\|f)ood"。

## python的正则表达式实现

python的正则表达式主要分为正则表达式对象，匹配对象以及匹配的字符串。在python中正则化通过调用`re`模块实现

### 正则表达式的函数

方法	|功能说明
:-|:-
compile(pattern[, flags])	|创建模式对象
escape(string)|	将字符串中所有特殊正则表达式字符转义
findall(pattern, string[, flags])|	返回包含字符串中所有与给定模式匹配的项的列表
finditer(pattern, string, flags=0)|	返回包含所有匹配项的迭代对象，其中每个匹配项都是match对象
fullmatch(pattern, string, flags=0)|	尝试把模式作用于整个字符串，返回match对象或None
match(pattern, string[, flags])	|从字符串的开始处匹配模式，返回match对象或None
purge()|	清空正则表达式缓存
search(pattern, string[, flags])|	在整个字符串中寻找模式，返回match对象或None
split(pattern, string[, maxsplit=0])|	根据模式匹配项分隔字符串
sub(pat, repl, string[, count=0])	|将字符串中所有与pat匹配的项用repl替换，返回新字符串，repl可以是字符串或返回字符串的可调用对象，作用于每个匹配的match对象
subn(pat, repl, string[, count=0])|	将字符串中所有pat的匹配项用repl替换，返回包含新字符串和替换次数的二元元组，repl可以是字符串或返回字符串的可调用对象，作用于每个匹配的match对象

### compile

通过compile函数我们可以将一个用来描述正则化的字符串变成模式对象。然后在其他函数中用于字符的匹配。

```python
import re
str1='this that'
type(re.compile(str1))
```

    re.Pattern

### match和search和finditer

match和search的区别就在于一个是开始处匹配一个是全字符串匹配。而match，search和finditer的区别在于前两个只返回第一个匹配值，而后一个返回所有的匹配值的迭代器。他们的相同点在于他们返回的都是match对象。而通过match对象，我们能得到很多结果。

* 对于贪心算法和第一个匹配值的理解

```python
str1='th this'
str2='t th this'
pattern=re.compile(r'\w+')
re.search(pattern,str2)
```

    <re.Match object; span=(0, 1), match='t'>

```python
re.search(pattern,str1)
```

    <re.Match object; span=(0, 2), match='th'>

```python
for i in re.finditer(pattern,str2):
    print(i)
```

    <re.Match object; span=(0, 1), match='t'>
    <re.Match object; span=(2, 4), match='th'>
    <re.Match object; span=(5, 9), match='this'>

所以是向应用第一个匹配值，再应用贪心算法

* match方法的属性和方法

属性 |说明
-|-
.string| 待匹配的文本
.re |匹配时使用的patter对象（正则表达式）
.pos |正则表达式搜索文本的开始位置
.endpos |正则表达式搜索文本的结束位置

方法| 说明
-|-
.group(0)| 获得匹配后的字符串
.groupdict()|返回包含匹配的所有命名子模式内容的字典
.start()| 匹配字符串在原始字符串的开始位置
.end() |匹配字符串在原始字符串的结束位置
.span()| 返回(.start(), .end())

```python
re.search(pattern,str1).pos
```

    0

```python
re.search(pattern,str1).endpos
```

    7

注意7是该字符串末尾序号的下一个位置。属性主要是返回匹配前的信息，方法主要是返回匹配后的信息。我们再来介绍一下group和groups函数

匹配对象方法|	描述
:-|:-
group(num=0)|	匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。
groups()	|返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。

groups和group返回的是一个match对象中原正则表达式中各个子模式的值。而finditer返回的各个match对象，也就是每一个match对象都包含这么多子模式

```python
mat=re.search(r'(\d)(\w)','3a95b6ddca8')
print(mat.groups())
print(mat.groupdict())#并没有已经命名的子模式
print(mat.group(0))
print(mat.group(1))
print(mat.group(2))
```

    ('3', 'a')
    {}
    3a
    3
    a

```python
mat.group(1,2)
```

    ('3', 'a')

```python
for i in re.finditer(r'(\d)(\w)','3a95b6ddca8'):
    print([i,i.group(0),i.group(1),i.group(2)])
```

    [<re.Match object; span=(0, 2), match='3a'>, '3a', '3', 'a']
    [<re.Match object; span=(2, 4), match='95'>, '95', '9', '5']
    [<re.Match object; span=(5, 7), match='6d'>, '6d', '6', 'd']

### flags参数

flags参数对应正则表达式的修饰符，但是并没有所有匹配这个选项了，因为另有函数。

修饰符	|描述
:-:|:-
re.I|	使匹配对大小写不敏感
re.L|	做本地化识别（locale-aware）匹配
re.M|	多行匹配，影响 ^ 和 $
re.S|	使 . 匹配包括换行在内的所有字符
re.U|	根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.
re.X|	该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。

### findall

findall也是找到所有匹配，所有的匹配是在贪心模式或非贪心模式下找完一个再找下一个。但他返回的是匹配的字符串组成的列表，而不是match对象。

### split

split可以用来分割字符串，将匹配的字符作为分隔符，剩下的字符被分割

```python
 example = r'one,two,three.four/five\six?seven[eight]nine|ten'
pattern = re.compile(r'[,./\\?[\]\|]')     #指定多个可能的分隔符
pattern.split(example)
example = r'one1two2three3four4five5six6seven7eight8nine9ten'
pattern = re.compile(r'\d+')               #使用数字作为分隔符
 pattern.split(example)
example = r'one two    three  four,five.six.seven,eight,nine9ten'
pattern = re.compile(r'[\s,.\d]+')         #允许分隔符重复
pattern.split(example)
```

    ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten']

### sub

检索和替换,Python 的re模块提供了re.sub用于替换字符串中的匹配项。其中的repl既可以是字符串也可以是函数

```python
import re
 
phone = "2004-959-559 # 这是一个电话号码"
 
## 删除注释
num = re.sub(r'#.*$', "", phone)
print ("电话号码 : ", num)
 
## 移除非数字的内容
num = re.sub(r'\D', "", phone)
print ("电话号码 : ", num)
```

    电话号码 :  2004-959-559 
    电话号码 :  2004959559

```python
 
import re
 
## 将匹配的数字乘于 2
def double(matched):
    value = int(matched.group('value'))
    return str(value * 2)
 
s = 'A23G4HFD567'
print(re.sub('(?P<value>\d+)', double, s))#这里用到了命名

```

    A46G8HFD1134

### 反向引用的实例

正则表达式|含义
-|:-
r'(\w)(?!.*\1)'|查找字符串中每个字符的最后一次出现。<br/>
r'(\w)(?=.*\1)'|查找字符串中所有重复出现的字符。<br/>
'(.)\\1+'|匹配任意字符的一次或多次重复出现。<br/>
'((?P<f>\b\w+\b)\s+(?P=f))'|匹配连续出现两次的单词。<br/>
'((?P<f>.)(?P=f)(?P<g>.)(?P=g))'|匹配AABB形式的成语或字母组合。

### 组合选择的实例

'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[,._]).{8,}\$'：检查给定字符串是否为强密码，必须同时包含英语字母大写字母、英文小写字母、数字或特殊符号<br/>（如英文逗号、英文句号、下划线），并且长度必须至少8位。<br/>
只有zhis没有that的字符串：<br/>
^(.(?<!that))*this(.(?<!that))*\$<br/>
^(.(?<!that))*this((?!that).)*\$<br/>
^((?!that).)*this(.(?<!that))*\$<br/>
^((?!that).)*this((?!that).)*\$

```python

```
