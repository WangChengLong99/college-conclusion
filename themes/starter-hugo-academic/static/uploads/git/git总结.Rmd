---
title: "git总结"
author: "wcl"
date: "2021年1月"
institute: 中南财经政法大学统计与数学学院
csl: ./style/chinese-gb7714-2015-numeric.csl
css: ./style/markdown.css
bibliography: [./Bibfile.bib]
eqnPrefixTemplate: ($$i$$)
link-citations: true
linkReferences: true
chapters: true
tableEqns: false
autoEqnLabels: false
classoption: "aspectratio=1610"
---

```{r setup, echo=F, purl=F}
knitr::opts_knit$set(root.dir = getwd())
knitr::opts_chunk$set(echo = TRUE, results = 'hide')
knitr::opts_chunk$set(warning = FALSE, message=FALSE)
knitr::opts_chunk$set(fig.align="center"
                      ## ,out.width="0.9\\textwidth" # latex
                      ,out.width="80%" # for both latex and html
                      ,fig.width=5, fig.height=3
                      )
```

```{r prepare, echo=F, purl=F}
rm(list=ls())
options(digits=4)
options(scipen=100)
graphics.off()
Sys.setlocale("LC_ALL", "Chinese")
library(reticulate)
```

# git是什么

git是一种版本控制工具。

版本控制工具可以记录文件的任意一个历史状态。有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态。就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。

* 版本控制工具
  1. 集中式：只有一台服务器，服务器一旦损坏就完蛋了。如svn。
  2. 分布式：各台电脑本身就有一个库，服务器损坏也无事。如git。

版本控制的优势：

* 协同修改
  * 多人协同工作
* 数据备份
  * 保存数据以及历史版本
* 版本管理
  * SVN 增量式管理，Git 文件系统快照
* 权限控制
  * 对开发人员进行权限控制，Git 还可对代码进行审核
* 历史记录
  * 查看修改人、修改时间、修改内容、日志信息
* 分支管理
  * 允许多线程推进同一个任务，提高效率

## Git 与 Svn 区别

* SVN

优点：

单一服务器，服务器保存所有文件的修订历史、每个人都可以看到项目中其他人在做什么，管理员可以轻松掌握每个开发者的权限。便于服务器管理，增量式管理，每次的历史记录只保存差异。

缺点：

如果服务器宕机，历史记录丢失，只有电脑保存最新版，无法协同工作。并且有丢失数据的风险。

SVN无法接受未授权的人提交的代码。这个特点适用于开源社区管理代码。

* Git

与 Linux 命令完全兼容

完全分布式，客户端并不只是提取最新版本的文件快照，而是把代码仓库完整的镜像下来，每一台电脑都是一台服务器，保存着整个项目的历史版本。因为压缩算法很厉害，所以储存能力很强。

对团队外开发者提交的代码进行审核----Git独有操作。

分布式版本控制系统，存放的不是差异，而是存放的索引（保存所有版本），即使断网也可以进行开发，因为版本都保存在本地。

尽可能添加数据而不是删除或修改数据，每次提交都会提交一个新的版本，不会删除旧的版本。

分支操作非常流畅

# Git 安装

官网地址：<https://git-scm.com/>

自己根据系统版本下载对应的版本，Windows，Linux，Unix

## Git 初始化

参数说明：

整个系统：system<br/>
当前用户：global<br/>
当前项目：留空,不需要参数

1. 设置用户名

`git config --global user.name 'username'`

2. 设置用户邮箱
   
`git config --global user.email 'useremail'`

3. 删除配置信息

`git config --global --unset user.name`
`git config --global --unset user.email`

## 配置所在位置

/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。

~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global 选项，读写的就是这个文件。

.git/config 文件：当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）这里的配置仅仅针对当前项目有效。

# git的结构与原理

## git 结构

首先git的结构可以分为三个部分：工作区(work tree),暂存区(index),本地库(repository也就是本地的数据库)。我们平时在我们文件系统中实际看到的就是工作区中的内容，但这时文件所在位置还并不能被称为工作区，因为我们还没有将这个文件所在位置给初始化成一个仓库。暂存区可以让我们在提交到本地库前做一个缓冲，可以在提交到本地库之前再次对工作区的内容进行操作，然后将暂存区相应的文件做出更新，再提交。而一旦提交之后本地库就会存储该版本的信息了。

![]('./../data/git结构.png)

而首先我们要做的就是将我们的项目（一般我们可以将一个文件夹视作项目）用git命令（git init）给初始化成一个git仓库，这时我们就可以进行一系列git操作了。当我们生成git仓库时，会默认生成一个.git的隐藏文件。该文件夹下内容如下：

![]('./../data/git文件内容.png)

<span style="color:red">注意：不要随意修改.git下的文件，否则可能会导致本地库出现错误<span>

## git原理

Git 的核心部分是一个简单的键值对数据库。你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索该内容。

不管是文件，还是最终提交的提交对象都是这样的原理。

首先一个文件可以看成是一个在Git中的一个git对象，git会利用hash（哈希）算法（其中一种SHA-1）为文件生成键值，然后通过对应文件键值可以检索任意一个文件内容，但是这个过程中我们丢失了文件名，丢失了文件结构。同时记住SHA-1值也不现实。所以Git中又引入了树对象，树对象可以让我们记住文件的目录。

<span style="color:red">注意：此时还只是在工作区的操作<span>

Git 以一种类似于 UNIX 文件系统的方式存储内容。所有内容均以树对象和数据对象(git 对象)的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象(git 对象)则大致上对应文件内容。一个树对象包含了一条或多条记录（每条记录含有一个指向 git 对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息）。一个树对象也可以包含另一个树对象。

**当文件被存到暂存区时**，才会被记录为一个树对象，此时又会生成一个哈希值，记录这次的树对象。树对象就可以看成是git的快照，他记录了一个版本中有哪些文件以及文件内容。在一次提交前的所有暂存区分批次记录的所有树对象会被合并成一个树对象。

然后当文件被commit提交后，会同时提交快照，以及配置的用户信息以及日志信息等生成的**提交对象**，这些会再度生成一个哈希值，通过这些哈希值就可以查找具体的版本了。

下一次版本更新会生成新的树对象，这时，如果所有的文件都被改了那么该树对象就是该版本的树对象，如果存在未变动的文件，则会生成指向文件的指针，不再额外记录。

在 Git 中每一个文件（数据）都对应一个 hash（类型 blob）

每一个树对象都对应一个 hash（类型 tree）

## git的版本管理图示

Git 把数据看作是小型文件系统的一组快照。每次提交更新时 Git 都会对当前 的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改， Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。所以 Git 的 工作方式可以称之为快照流。

![](./data/git版本保存.png)

这里方框为虚线的就是指向之前的指针。

* Git 的“提交对象”
  ![](data/git提交对象.png)

* 提交对象及其父对象生成的链条
  ![](data/提交对象链条.png)

# git的操作

## git仓库初始化

git bash only:到所在目录下打开git bash 

git and windows:到所在目录下，在空白处，按住<kbd>shift</kbd>并且右键双击，会出现打开powershell选项，点击后，输入cmd，进入cmd或者直接打开cmd手动把路径设置到该目录

`git init`

此时会生成隐藏文件.git,它存储了本地库的信息

## git仓库删除

`rm -rf .git`

删除.git文件就是删除本地库

## 查看此时的git仓库状态

此时我们已将项目给初始化成git仓库了，我们需要查看git仓库的状态，输入

`git status`

可以看到当前未追踪（untracked）的文件，代表工作区的文件还没有添加到暂存区，如果我们将文件添加到暂存区后，此时再看改文件的状态就会变成'unmodified'(追踪且未修改）。如果我们在将暂存区文件commit提交之前，又对该文件做出了修改，则该文件状态会变成‘modified’，再次add，则会变成‘staged’，commit之后就会变回‘unmodified’，<span style="color:red">注意：此时该文件依然是追踪的</span>,那么下一次版本更新如果变动了改文件依然会是被追踪到的，总结就是只要一次提交之后，改文件永远被追踪。除非删除信息被提交。

文件状态分为两种，已跟踪和未跟踪，已跟踪又分为三种状态：已暂存、已修改、已提交

* 未跟踪
  * 表示没有加入暂存区，也不在版本库中有快照，还处于工作区，任意修改都不会对Git有影响，也不会有记录
* 已跟踪（已有快照文件）
* 已暂存
  * 表示生成Git对象，推送到暂存区
* 已修改
  * 表示生成Git对象后，文件已经在暂存区，又对本地文件进行修改，此时如果想要提交，需要再次推送到暂存区更新文件
*  已提交
  * 表示将暂存区文件推送到版本库，生成历史版本

<span style="color:red">注意：没有文件的文件夹是不会被显示的，也就是状态中不会显示</span>

![](./data/文件状态.png)

## 将文件添加到暂存区

`git add`

`git add filename`添加某个文件

`git add path`添加某个路径下的所有文件

`git add ./ #将当前路径下的所有文件添加，添加后状态为所有文件的路径` 当我们再次在工作区对某些文件做出了修改后，依然可以再度使用这个命令暂存文件，不会和已经暂存的起冲突，已经暂存的不会再度生成文件。

将文件添加到暂存区，该文件状态变为被追踪，那么接下来该文件的任何操作都会被追踪，（如果把一个文件从一个文件夹移到了另一个文件夹会怎么样）。

`git ls-files -s`查看暂存区当前的样子

### 该操作可以被撤销

`git reset HEAD 文件名`只对于本地库已经有过一个提交版本之后

`git restore --staged filename  # 新版命令`本电脑不行

`git rm --cached filename/path #本电脑命令,对于文件`任何时候

`git rm -r --cached foldername/path #本电脑命令，对于文件夹`

`git rm -r --cached ./`取消该目录下已经add到暂存区的文件，重回工作区。

当我们把文件添加到暂存区后，文件就是被追踪的状态，此时文件的修改git都是知道的，当我们在工作区再度修改文件时，文件的状态就是会变成‘modified’，此时我们可以查看工作区文件与暂存区差异。

### 查看工作区文件与暂存区差异

`git diff filename`

1. 当前做的哪些更新还没有暂存？
  
命令：`git diff`（不加参数直接输入 git diff）

2. 有哪些更新已经暂存起来准备好了下次提交？(能看到所有文件信息)
  
命令： `git diff –cached` 或者 `git diff –staged`(1.6.1 以上)

**多屏显示控制方式： 空格向下翻页 b 向上翻页 q 退出**

### 暂存后对工作区文件修改

1. 可以用vim直接在git中修改

vim 文件的 url(在英文模式下)

按 i 进插入模式 进行文件的编辑 

按 esc 键&按:键 进行命令的执行

q! 强制退出（不保存）

wq 保存退出

set nu 设置行号

2. 可以在工作区修改

不管怎么修改，修改的结果必须添加到暂存区，才能提交到本地库，否则提交的只是原暂存区中的内容。

### 暂存后删除工作区文件

1. 直接在工作区删除
   删除后，此时可以发现git status该文件变成deleted，必须再进行git add filename，git commit filename提交删除信息。这时暂存区就没有改文件的信息了。

2. 通过git命令删除
   git rm -f filename#这个就是删除并添加到暂存库，最后只要再进行git commit即可，即可生成没有该文件的版本。
   
   `git rm -r -f foldername`

   第一次需要加f，已经提交后，处于追踪状态，删除时就不需要加f了，并且自动默认删除信息会添加到暂存库。

**恢复文件**

如果文件之前被提交过，则可以通过回溯到之前的版本，恢复文件。

`git reset --hard [指针位置]`

删除操作已经提交到本地库：指针位置指向历史记录 ，历史记录的索引

删除操作尚未提交到本地库：指针位置使用 HEAD，即`git reset --hard HEAD`这就是重置到上一次提交之后的状态。

### 暂存后重命名文件

1. 直接在工作区修改
   此时就相当于删除一个文件，并且新建一个文件。同样需要git add，和git commit
2. 通过git命令重命名
   `git mv original_filename new_filename`此时相当于进行了重命名并且添加到暂存区。
   
### 暂存后添加新文件

1. 使用`echo '内容' > filename`
2. 直接在工作区创建新文件。
3. vim newfilename 创建并且编辑

并不会影响，因为这个新文件是未被追踪的文件

##  将文件推送到本地库，提交

`git commit filename/path`

这样会弹出输入框让你输入信息

`git commit -m "描述信息" filename/path`

直接加-m，在后面输入版本的描述信息。

对于已经提交过的文件，那就是被追踪的状态。如果对已经在版本库中有快照的文件，在工作区进行修改，不想再用 git add 命令更新暂存区，可以使用 -a 参数直接提交到版本库。没有被跟踪的文件无法使用 -a

`git commit -a`

对于修改和删除，可以直接利用git commit -a提交

但是对于重命名，删除的部分可以提交，因为这是基于追踪文件，但是新命名的文件属于未追踪，不会被提交，依然是untracked，想要一并提交，必须先git add。

**查看工作区文件和当前版本的差别：**

前提是已追踪

`git diff HEAD`

git diff [本地库中历史版本hash值] [文件名] 

将工作区中的文件和本地库历史记录比较

不加文件就是跟历史版本比较

### 重置提交

命令: `git commit --amend`

作用:

这个命令会将暂存区中的文件提交。如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息如果你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作

    git commit -m 'initial commit'
    git add forgotten_file
    git commit –amend

最终你只会有一个提交 - 第二次提交将代替第一次提交的结果

### 查看历史记录

查看提交记录

git log

可以查看所有文件被提交到版本库时候的详细信息，可以用下方代码查看简要信息：

git log --pretty=oneline
git log --oneline
git reflog

git reflog 可以显示 HEAD@{1} 字样，自动计算你的指针

**git reflog可以记录任何时候你对指针的所有操作**

查看项目分叉历史

git log --online --decorate --graph --all

## 使用reset命令实现版本的回溯，前进后退

* 基于索引值操作[推荐] 
  * git reset --hard [局部索引值]
  * git reset --hard a6ace91 
* 使用^符号：只能后退 
  * git reset --hard HEAD^ 
  * 注：一个^表示后退一步，n 个表示后退 n 步 
* 使用~符号：只能后退 
  * git reset --hard HEAD~n 
  * 注：表示后退 n 步

注意使用hard时，三个区域一起变动，可能会造成文件的冲突，破坏等。最好在回溯之前将文件都暂存并且提交。

--soft 参数  仅仅在本地库移动 HEAD 指针

--mixed 参数 在本地库移动 HEAD 指针  重置暂存区

--hard 参数 在本地库移动 HEAD 指针  重置暂存区 重置工作区

HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。这表示 HEAD 将是下一次提交的父结点。通常，理解 HEAD 的最简方式，就是将它看做 当前提交 的快照。

reset移动的是head所指向分支的指向，head还是指向这个分支

checkout移动head指针，head会指向另一个分支的最新版本。

### 移动 HEAD 图示

reset 做的第一件事是移动 HEAD 的指向。
假设我们再次修改了 file.txt 文件并第三次提交它。 现在的历史看
起来是这样

![](./data/reset移动1.png)

**git reset –-soft HEAD~**

这与改变 HEAD 自身不同（checkout 所做的）；reset 移动 HEAD 指向的分支。图上也就是master。

![](./data/reset移动2.png)

看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 git
commit 命令。 当你在运行 git commit 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。

当你将它 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移
动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 git commit 来完成 git commit --amend 所要做的事情了

**也就是保存上一次提交的暂存区和工作区，相当于没有提交，回到提交之前的状态，但是版本已经变成你想回溯的版本了**

**更新暂存区（索引）--mixed**

![](./data/mixed移动.png)

<span style="color:red">注意 `git reset HEAD~` 等同于 `git reset –mixedHEAD~`</span>

理解一下发生的事情：它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。

**也就是现在暂存区的文件状态和版本一致，只有工作区不一样**

**更新工作目录，--hard**

![](./data/hard移动.png)

你撤销了最后的提交、git add 和 git commit 命令以及工作目录
中的所有工作。

必须注意，--hard 标记是 reset 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 reset 调用都可以轻松撤消，但是 --hard 选项不能，因为它强制覆盖了工作目录中的文件。在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 v3 版本，我们可以通过 reflog 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复.

**也就是如果我们我们目前状态对文件修改了，但是没有提交。那么当我们回到之前的版本时，改修改的信息就丢掉了，因为该版本并没有提交。但是如果我们提交了，那么通过`git reflog`我们可以再次查看所有已提交的版本信息，通过hash值回到之前的状态**，

git log等查看历史记录只能看到当前指针下所有之前提交的信息，并不能看到之后提交的版本。所以如果版本回退了，是看不到最新的版本的。只有Git reflog能做到。

`git branch recover-branch branch_hash`

重新创建一个分支，指向自己之前的分支，就可以恢复文件了。这种方法更为常用。


### reset其他应用，后面加文件

`git reset filename`

`git reset HEAD filename`

撤销添加到暂存区。

## git创建分支

在版本控制过程中，使用多条线同时推进多个任务。

![](data/分支图示.png)

* 分支的好处？ 
  * 同时并行推进多个功能开发，提高开发效率 
  * 各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任 何影响。失败的分支删除重新开始即可。

* 创建分支 `git branch [分支名]`,可以创建一个新的分支。会在当前所在的提交对象上创建一个指针

![](./data/创建分支.png)

* 查看分支 `git branch`
* 查看分支最后一次提交 `git branch -v` 
* 切换分支 `git checkout [分支名]`
  <span style="color:red;background-color:yellow">注意：切换分支会改变你的工作目录中的文件，所以再每次切换分支前，git status 查看一下是否都被提交，如没有则需要提交保存一下当前分支，否则未保存的文件会遗留到切换到的分支中。造成分支污染。</span>

切换分支会对工作区实际文件、暂存区、HEAD 进行改变。

* 新建一个分支并且同时切换到该分支,`git checkout -b branch_name`

* 在之前的提交对象上新建一个分支，实现历史回滚,`git branch name commitHash`

可以利用 log 查看分支hash，然后直接从之前的版本开启分支

* 删除分支
  * `git branch -d branch_name`  # 删除已合并的分支
  * `git branch -D branch_name`  # 强制删除未合并的分支

不可以删除当前所在分支

* 合并分支  
  * 第一步：切换到接受修改的分支（被合并，增加新内容）上 `git checkout [被合并分支名]`
  * 第二步：执行 merge 命令 `git merge [有新内容分支名]`

**查看合并到当前分支的列表**

`git branch --merged`

如果出现列表，代表该分支已经合并，可以进行删除

**查看未合并的分支列表**

`git branch --no-merged`

如果出现在这个列表中，应该考虑是否需要合并分支

### 分支合并的原理和方法

分支是为了协同工作。可能我们一开始就是各自在各自的分支下工作，这时互不影响，之后合并即可。也可能就是先完成一部分共同开发，在这个基础上，各自做自己的。但是如果不同的分支对之前相同的部分做了不同的修改，那么在合并时git并不能抉择选择何种改变。就会起冲突。有或是某个地方出了错，分一个分支从这个出错的地方去解决这个问题，其他人继续做其他工作，改文件只有那个分支的人改，那个人解决了错误后再合并会来，那么文件的修改也会被合并上来。

#### 快速合并分支

`git merge branch_name`


最后一次提交已经修改好的 hotfix 分支，然后切换到主分支，然后用 merge 命令合并该分支到主分支。测试完成后用 git rm 删除已经合并过的 hotfix 分支。

![](data/快速合并.png)
![](data/快速合并2.png)

#### 典型合并

如果之前在 Master 分支上开过其他分支，那么这时候，其他分支已经过期，因为这些分支是从Merge前引出的分支，所以，这些分支并没有更新到Master的最新版本。用了 merge 命令后，会提示需要手动更改，将冲突的文件修复，然后用 git add 和 git commit 提交到版本库中完成Merge，这种合并称为典型合并

![](data/典型合并1.png)
![](data/典型合并2.png)

#### Git Merge 的三种方式：

* 快速合并
  `git merge branch_name`

不会显示 feature，只保留单条分支记录。fast-forward方式合并， feature 的提交历史混入到 master 中

![](data/merge1.png)

* 禁止快速合并
  git merge --no-ff branch_name

不使用fast-forward方式合并，可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。推荐这种

![](data/merge3.png)

* 使用squash方式合并
  `git merge --squash branch_name ` 

--squash选项的含义是：本地文件内容与不使用 --squash 的合并结果相同，但是不提交、不移动HEAD，因此需要一条额外的commit命令。其效果相当于将 feature 分支上的多个commit合并成一个，放在 Master 分支上，原来的 Feature commit 历史则没有拿过来。

![](data/merge2.png)

用 log 感觉更清晰一些， add fa 是用的 -ff 快速合并，我们并不知道这个 commit 其实是从分支上过来的，git 只是做了一个 HEAD 移动，而 add fb 是用 --no-ff 合并的，可以清楚看到这个是分支，并且在 Master 主线上我们做了一个合并的图示。

![](data/合并图示.png)

#### Rebase 和 Merge 区别

![](data/RM不同1.png)

正常来说，如果 feature 这个 branch 是从 M2 开发的，那么在主线 Master 已经推进到 M3 时，需要进行 Merge ，我们只会多出一个 Merged Commit。 如 M3 - Merged Commit with Feature

但是如果用了 Rebase 方式进行合并的话，

![](data/RM不同2.png)

在 Feature 分支中，会在 M2 的基础上，自动补你当前代码到 M3，然后合并你的 F1 。结构如下 M3-F1

之后你的 Feature 分支可以在最新的主线基础上再继续开发到 F2，当开发完成时，我们要将 F2 合并到 Master 中，此时再切换到 Master 分支再进行 Rebase 合并，主线分支记录则会变成 M1-M2-M3-F1-F2，将程序所有的改动在主线上一条线清晰的延续。

总结：Rebase 更能体现项目的过程， Merge 更关注历史记录

官方建议可以在自己本地进行 Rebase，但是多人团队中的 Master 中最好不要用 Rebase 方式进行合并。会造成代码的混乱。

Do not rebase commits that exist outside your repository and that people may have based work on.

官方也给了解释原因：<https://git-scm.com/book/en/v2/Git-Branching-Rebasing>

### 合并的冲突

冲突来源于对不同文件的不同修改，只要文件之间不存在冲突,那么合并一定是能够成功的。

解决方法：

* 第一步：编辑文件，删除特殊符号 
* 第二步：把文件修改到满意的程度，保存退出 
* 第三步：git add [文件名]  
* 第四步：git commit -m "日志信息" <span style="color:red"> 注意：此时 commit 一定不能带具体文件<span>

## git checkout

不带路径 

`git checkout [branch]`

运行 `git checkout [branch]` 与运行 `git reset --hard[branch]` 非常相似，它会更新三者使其看起来像 [branch]，不过有两点重要的区别

首先不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。而 reset --hard 则会不做检查就全面地替换所有东西。

第二个重要的区别是如何更新 HEAD。 reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支。

例如，假设我们有 master 和 develop 分支，它们分别指向不同的提
交；我们现在在 develop 上。 如果我们运行 git reset master，那
么 develop 自身现在会和 master 指向同一个提交。而如果我们运行 git checkout master 的话，develop 不会移动，HEAD 自身会移动。 现在HEAD 将会指向 master。

所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但_
做法_是非常不同的。 reset 会移动 HEAD 分支的指向，而 checkout 则移动 HEAD 自身。

![](data/checkout逻辑.png)

## git存储

当所在项目已经工作了一段时间，需要紧急切换到其他分支，但本分支的任务没有完成，我们可以将本分支的工作储存到栈中。命令如下，本质上还是提交，但是不保存在提交记录中。

* Git 存储
  `git stash`
* Git 存储还原
  `git stash apply`

当任务完成时，切回本分支，可以使用下方命令还原状态，但是栈中还是会保留之前的存储对象。切回本分支时，最好再次查看一下状态 git status，然后再还原存储的任务。

* 查看存储
  `git stash list`

当前任务保存在栈中，存储对象名为 stash@{0} ，大括号中为存储顺序编号

* 还原指定存储
  `git stash apply stash@{2}` # 如果不指定一个储藏，Git认为指定的是最近的储藏

* 删除栈中的存储
  `git stash drop stash@{0}`

* 还原并删除栈中的存储
  `git stash pop`  # 最好在只有一个存储的情况下

## TAG - 标签

git 可以给历史中的某一个提交打上标签，一般用标签来标注版本号

* 查看标签
  * git tag  # 列出所有tag标签
  * git tag -l 1.8.5*  # *为通配符，列出1.8.5xxxxxx之类的所有tag

* 创建标签
  * git tag v1.4  # 标注最后一次提交对象
  * git tag v1.4 commithash  # 标注指定提交对象

* 查看特定标签
  * git show v1.0  

* 删除标签
  * git show -d v1.0

* 检出标签
  * git checkout v1.0

在检出标签模式下，会处于头部分离状态，可以查看当前分支的状态，但是最好不要commit，如果此时进行了提交，标签不会发生变化，新提交也不会属于任何分支，并且无法访问。除非访问确切的Hash。

因此，如果想要修改，最后使用 git branch -b branch_name 来创建分支进行修改

## git将本地库内容push到远程库

远程库是保存代码的仓库，目前比较好的是github和gitte（码云）

这里我们选择连接github

首先我们需要现在github上创建一个库，创建好之后，会出现该库的网络地址和ssh地址，我们可以选择ssh地址，也可以选择网络地址。但是选择ssh地址需要我们首先配置好ssh密钥与github以及码云的连接。

### ssh密钥生成与连接

    $ ssh-keygen -t ed25519 -C "your_email@example.com"
    $ eval `ssh-agent -s`
    $ ssh-add ~/.ssh/id_ed25519

为了验证本地电脑与Github之间的ssh通讯是否正常，我们可以使用如下命令：

`ssh -T git@github.com`

### 具体推送过程

`git remote -v `查看当前所有远程地址别名 

`git remote add [别名] [远程地址]` 

推送`git push [别名] [分支名]`

这里的远程地址分为http地址和ssh地址，如果选择http，则每次提交的时候都需要输入用户民密码，而如果是ssh的话，则不需要。

### 克隆

直接 `git clone [http地址]`

### 团队成员邀请

![](./data/第22页-3.PNG)
![](./data/第22页-2.PNG)
![](./data/第22页-1.PNG)

“岳不群”其他方式把邀请链接发送给“令狐冲”，“令狐冲”登录自己的 GitHub 账号，访问邀请链接。

![](./data/接受邀请.png)

### 拉取

当成员更新了我们的远程库的项目时，如何保存到本地库。

pull=fetch+merge

`git fetch [远程库地址别名] [远程分支名]`

`git merge [远程库地址别名/远程分支名]`

`git pull [远程库地址别名] [远程分支名]`

### 跨团队协作

pull request 流程

如果你想要参与某个项目，但是并没有推送权限，这时可以对这个项
目进行“派生”（Fork）。 派生的意思是指，GitHub 将在你的空间中创
建一个完全属于你的项目副本，且你对其具有推送权限。通过这种方式，
项目的管理者不再需要忙着把用户添加到贡献者列表并给予他们推送权
限。 人们可以派生这个项目，将修改推送到派生出的项目副本中，并通
过创建合并请求（Pull Request）来让他们的改动进入源版本库。
基本流程：
1. 从 master 分支中创建一个新分支 （自己 fork 的项目）
2. 提交一些修改来改进项目 （自己 fork 的项目）
3. 将这个分支推送到 GitHub 上 （自己 fork 的项目）
4. 创建一个合并请求
5. 讨论，根据实际情况继续修改
6. 项目的拥有者合并或关闭你的合并请求

注意点：

每次在发起新的 Pull Request 时 要去拉取最新的源仓库的代码
而不是自己 fork 的那个仓库。

`git remote add <shortname 源仓库> <url 源仓库>`

`git fetch 远程仓库名字`

`git merge 对应的远程跟踪分支`

## 补充

* 还原工作区文件

`git checkout --filename`

`git resotre filename`  # 新版本推荐使用

当在工作区做了文件修改，但是文件未被上传到暂存区或版本库中，可以用以上命令来还原文

`git checkout -- [file]` 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。除非你确实清楚不想要那个文件了，否则不要使用这个命令

HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。
这表示 HEAD 将是下一次提交的父结点。通常，理解 HEAD 的最简方式，就是将它看做 当前提交 的快照。

`git cat-file -p HEAD`查看当前提交对象

`git ls-tree -r HEAD`查看当前提交对象对应的树对像的内容

# 参考书籍或笔记

<a href="https://note.youdao.com/ynoteshare1/index.html?id=aa402b3b172d3876c5af053d2c790e54&type=note" target="_blank">参考笔记</a>

<a href="file:///C:/Users/WangChengLong/Desktop/%E7%BC%96%E7%A8%8B/git/git%E6%80%BB%E7%BB%93/data/Git&GitHub.pdf" target="_blank">易理解版书籍</a>

<a href="file:///C:/Users/WangChengLong/Desktop/%E7%BC%96%E7%A8%8B/git/git%E6%80%BB%E7%BB%93/data/01_Git.pdf" target="_blank">深度版书籍</a>

# 参考文献
[//]: # (\bibliography{Bibfile})


